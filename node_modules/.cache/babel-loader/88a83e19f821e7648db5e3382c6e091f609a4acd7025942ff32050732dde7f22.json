{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ramja\\\\Desktop\\\\Pathfinding Visualiser\\\\Path-finding-visualiser-main\\\\src\\\\components\\\\Visualizer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport Node from './Node';\nimport './Visualizer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Visualizer = () => {\n  _s();\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [startNode, setStartNode] = useState(null);\n  const [endNode, setEndNode] = useState(null);\n  const isVisualizingRef = useRef(false);\n  const [timeTaken, setTimeTaken] = useState(0);\n  const initializeGrid = useCallback(() => {\n    const initialGrid = [];\n    for (let row = 0; row < 50; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      initialGrid.push(currentRow);\n    }\n    setGrid(initialGrid);\n  }, []);\n  useEffect(() => {\n    initializeGrid();\n  }, [initializeGrid]);\n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isStart: false,\n      isEnd: false\n    };\n  };\n  const handleMouseUp = () => {\n    if (isVisualizingRef.current) return;\n    setMouseIsPressed(false);\n  };\n  const handleMouseDown = (row, col) => {\n    if (isVisualizingRef.current) return;\n    if (grid[row][col].isStart) {\n      setMouseIsPressed('start');\n    } else if (grid[row][col].isEnd) {\n      setMouseIsPressed('end');\n    } else {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed('wall');\n    }\n  };\n  const handleMouseEnter = (row, col) => {\n    if (isVisualizingRef.current) return;\n    if (!mouseIsPressed) return;\n    if (mouseIsPressed === 'start') {\n      const newGrid = getNewGridWithUpdatedStartNode(grid, row, col);\n      setGrid(newGrid);\n    } else if (mouseIsPressed === 'end') {\n      const newGrid = getNewGridWithUpdatedEndNode(grid, row, col);\n      setGrid(newGrid);\n    } else {\n      const newGrid = getNewGridWithUpdatedNode(grid, row, col);\n      setGrid(newGrid);\n    }\n  };\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  const getNewGridWithUpdatedNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    let newNode;\n    if (mouseIsPressed === 'wall') {\n      newNode = {\n        ...node,\n        isWall: !node.isWall\n      };\n      newGrid[row][col] = newNode;\n    } else {\n      // Handle other cases here if needed\n    }\n    return newGrid;\n  };\n  const getNewGridWithUpdatedStartNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: true,\n      isEnd: false\n    };\n    const prevStartNode = startNode;\n    if (prevStartNode !== null) {\n      const prevStartNodeRow = prevStartNode.row;\n      const prevStartNodeCol = prevStartNode.col;\n      newGrid[prevStartNodeRow][prevStartNodeCol] = {\n        ...prevStartNode,\n        isStart: false\n      };\n    }\n    newGrid[row][col] = newNode;\n    setStartNode(newNode);\n    return newGrid;\n  };\n  const getNewGridWithUpdatedEndNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: false,\n      isEnd: true\n    };\n    const prevEndNode = endNode;\n    if (prevEndNode !== null) {\n      const prevEndNodeRow = prevEndNode.row;\n      const prevEndNodeCol = prevEndNode.col;\n      newGrid[prevEndNodeRow][prevEndNodeCol] = {\n        ...prevEndNode,\n        isEnd: false\n      };\n    }\n    newGrid[row][col] = newNode;\n    setEndNode(newNode);\n    return newGrid;\n  };\n  const visualizeAlgorithm = algorithm => {\n    if (isVisualizingRef.current) return;\n    if (!startNode || !endNode) {\n      alert('Please select both start and end nodes.');\n      return;\n    }\n    isVisualizingRef.current = true;\n    let visitedNodesInOrder = [];\n    let shortestPath = [];\n    if (algorithm === 'dijkstra') {\n      visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'astar') {\n      visitedNodesInOrder = astar(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'bfs') {\n      visitedNodesInOrder = bfs(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'dfs') {\n      visitedNodesInOrder = dfs(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    }\n    animateAlgorithm(visitedNodesInOrder, shortestPath);\n  };\n  const dijkstra = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) break;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === endNode) break;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n    return visitedNodesInOrder;\n  };\n  const astar = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    startNode.heuristic = calculateHeuristic(startNode, endNode);\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) break;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === endNode) break;\n      updateAStarUnvisitedNeighbors(closestNode, endNode, grid, unvisitedNodes);\n    }\n    return visitedNodesInOrder;\n  };\n  const bfs = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    const queue = [];\n    queue.push(startNode);\n    while (queue.length) {\n      const currentNode = queue.shift();\n      if (currentNode.isWall) continue;\n      if (currentNode.isVisited) continue;\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      if (currentNode === endNode) break;\n      const neighbors = getNeighbors(currentNode, grid);\n      for (const neighbor of neighbors) {\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n    return visitedNodesInOrder;\n  };\n  const dfs = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    const stack = [];\n    stack.push(startNode);\n    while (stack.length) {\n      const currentNode = stack.pop();\n      if (currentNode.isWall) continue;\n      if (currentNode.isVisited) continue;\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      if (currentNode === endNode) break;\n      const neighbors = getNeighbors(currentNode, grid);\n      for (const neighbor of neighbors) {\n        neighbor.previousNode = currentNode;\n        stack.push(neighbor);\n      }\n    }\n    return visitedNodesInOrder;\n  };\n  const getAllNodes = grid => {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  };\n  const sortNodesByDistance = unvisitedNodes => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  };\n  const sortNodesByHeuristic = unvisitedNodes => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance + nodeA.heuristic - (nodeB.distance + nodeB.heuristic));\n  };\n  const updateUnvisitedNeighbors = (node, grid) => {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  };\n  const updateAStarUnvisitedNeighbors = (node, endNode, grid, unvisitedNodes) => {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      const distanceToNeighbor = node.distance + 1;\n      if (distanceToNeighbor < neighbor.distance) {\n        neighbor.distance = distanceToNeighbor;\n        neighbor.previousNode = node;\n        neighbor.heuristic = calculateHeuristic(neighbor, endNode);\n      }\n    }\n    sortNodesByHeuristic(unvisitedNodes);\n  };\n  const calculateHeuristic = (node, endNode) => {\n    const dx = Math.abs(node.col - endNode.col);\n    const dy = Math.abs(node.row - endNode.row);\n    return dx + dy;\n  };\n  const getNeighbors = (node, grid) => {\n    const {\n      col,\n      row\n    } = node;\n    const neighbors = [];\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  };\n  const getShortestPath = endNode => {\n    const shortestPath = [];\n    let currentNode = endNode;\n    while (currentNode !== null) {\n      shortestPath.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n  };\n  const animateAlgorithm = (visitedNodesInOrder, shortestPath) => {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 10 * i);\n    }\n    setTimeout(() => {\n      animateShortestPath(shortestPath);\n    }, 10 * visitedNodesInOrder.length);\n  };\n  const animateShortestPath = shortestPath => {\n    for (let i = 0; i < shortestPath.length; i++) {\n      setTimeout(() => {\n        const node = shortestPath[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, 50 * i);\n    }\n    setTimeout(() => {\n      isVisualizingRef.current = false;\n      const timeElapsed = 50 * shortestPath.length;\n      setTimeTaken(timeElapsed);\n    }, 50 * shortestPath.length);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"visualizer\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"button-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Pathfinder\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 380,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => setMouseIsPressed('start'),\n        children: \"Select Start Node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => setMouseIsPressed('end'),\n        children: \"Select End Node\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 387,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => setMouseIsPressed('wall'),\n        children: \"Add Walls\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 393,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => visualizeAlgorithm('dijkstra'),\n        children: \"Dijkstra's Algorithm\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 399,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => visualizeAlgorithm('astar'),\n        children: \"A* Search\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 405,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => visualizeAlgorithm('bfs'),\n        children: \"BFS\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 411,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"visualizer-button\",\n        onClick: () => visualizeAlgorithm('dfs'),\n        children: \"DFS\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 417,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 379,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"time-taken\",\n      children: [\"Time Taken: \", timeTaken, \" ms\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 424,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid.map((row, rowIndex) => {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"row\",\n          children: row.map((node, nodeIndex) => {\n            const {\n              col,\n              row,\n              isStart,\n              isEnd,\n              isWall\n            } = node;\n            return /*#__PURE__*/_jsxDEV(Node, {\n              col: col,\n              row: row,\n              isStart: isStart,\n              isEnd: isEnd,\n              isWall: isWall,\n              mouseIsPressed: mouseIsPressed,\n              onMouseDown: () => handleMouseDown(row, col),\n              onMouseEnter: () => handleMouseEnter(row, col),\n              onMouseUp: handleMouseUp\n            }, nodeIndex, false, {\n              fileName: _jsxFileName,\n              lineNumber: 434,\n              columnNumber: 19\n            }, this);\n          })\n        }, rowIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 430,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 427,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 378,\n    columnNumber: 5\n  }, this);\n};\n_s(Visualizer, \"y+LvrU+8fHlRz3uLupOYC1R4P/A=\");\n_c = Visualizer;\nexport default Visualizer;\nvar _c;\n$RefreshReg$(_c, \"Visualizer\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","Node","jsxDEV","_jsxDEV","Visualizer","_s","grid","setGrid","mouseIsPressed","setMouseIsPressed","startNode","setStartNode","endNode","setEndNode","isVisualizingRef","timeTaken","setTimeTaken","initializeGrid","initialGrid","row","currentRow","col","push","createNode","distance","Infinity","isVisited","isWall","previousNode","isStart","isEnd","handleMouseUp","current","handleMouseDown","newGrid","getNewGridWithWallToggled","handleMouseEnter","getNewGridWithUpdatedStartNode","getNewGridWithUpdatedEndNode","getNewGridWithUpdatedNode","node","newNode","prevStartNode","prevStartNodeRow","prevStartNodeCol","prevEndNode","prevEndNodeRow","prevEndNodeCol","visualizeAlgorithm","algorithm","alert","visitedNodesInOrder","shortestPath","dijkstra","getShortestPath","astar","bfs","dfs","animateAlgorithm","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","heuristic","calculateHeuristic","updateAStarUnvisitedNeighbors","queue","currentNode","neighbors","getNeighbors","neighbor","stack","pop","nodes","sort","nodeA","nodeB","sortNodesByHeuristic","distanceToNeighbor","dx","Math","abs","dy","filter","unshift","i","setTimeout","document","getElementById","className","animateShortestPath","timeElapsed","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","map","rowIndex","nodeIndex","onMouseDown","onMouseEnter","onMouseUp","_c","$RefreshReg$"],"sources":["C:/Users/ramja/Desktop/Pathfinding Visualiser/Path-finding-visualiser-main/src/components/Visualizer.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport Node from './Node';\nimport './Visualizer.css';\n\nconst Visualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [startNode, setStartNode] = useState(null);\n  const [endNode, setEndNode] = useState(null);\n  const isVisualizingRef = useRef(false);\n  const [timeTaken, setTimeTaken] = useState(0);\n\n  const initializeGrid = useCallback(() => {\n    const initialGrid = [];\n    for (let row = 0; row < 50; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      initialGrid.push(currentRow);\n    }\n    setGrid(initialGrid);\n  }, []);\n\n  useEffect(() => {\n    initializeGrid();\n  }, [initializeGrid]);\n\n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isStart: false,\n      isEnd: false,\n    };\n  };\n\n  const handleMouseUp = () => {\n    if (isVisualizingRef.current) return;\n    setMouseIsPressed(false);\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (isVisualizingRef.current) return;\n\n    if (grid[row][col].isStart) {\n      setMouseIsPressed('start');\n    } else if (grid[row][col].isEnd) {\n      setMouseIsPressed('end');\n    } else {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed('wall');\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (isVisualizingRef.current) return;\n\n    if (!mouseIsPressed) return;\n\n    if (mouseIsPressed === 'start') {\n      const newGrid = getNewGridWithUpdatedStartNode(grid, row, col);\n      setGrid(newGrid);\n    } else if (mouseIsPressed === 'end') {\n      const newGrid = getNewGridWithUpdatedEndNode(grid, row, col);\n      setGrid(newGrid);\n    } else {\n      const newGrid = getNewGridWithUpdatedNode(grid, row, col);\n      setGrid(newGrid);\n    }\n  };\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const getNewGridWithUpdatedNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    let newNode;\n\n    if (mouseIsPressed === 'wall') {\n      newNode = {\n        ...node,\n        isWall: !node.isWall,\n      };\n      newGrid[row][col] = newNode;\n    } else {\n      // Handle other cases here if needed\n    }\n\n    return newGrid;\n  };\n\n  const getNewGridWithUpdatedStartNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: true,\n      isEnd: false,\n    };\n    const prevStartNode = startNode;\n    if (prevStartNode !== null) {\n      const prevStartNodeRow = prevStartNode.row;\n      const prevStartNodeCol = prevStartNode.col;\n      newGrid[prevStartNodeRow][prevStartNodeCol] = {\n        ...prevStartNode,\n        isStart: false,\n      };\n    }\n    newGrid[row][col] = newNode;\n    setStartNode(newNode);\n    return newGrid;\n  };\n\n  const getNewGridWithUpdatedEndNode = (grid, row, col) => {\n    const newGrid = [...grid];\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: false,\n      isEnd: true,\n    };\n    const prevEndNode = endNode;\n    if (prevEndNode !== null) {\n      const prevEndNodeRow = prevEndNode.row;\n      const prevEndNodeCol = prevEndNode.col;\n      newGrid[prevEndNodeRow][prevEndNodeCol] = {\n        ...prevEndNode,\n        isEnd: false,\n      };\n    }\n    newGrid[row][col] = newNode;\n    setEndNode(newNode);\n    return newGrid;\n  };\n\n  const visualizeAlgorithm = (algorithm) => {\n    if (isVisualizingRef.current) return;\n    if (!startNode || !endNode) {\n      alert('Please select both start and end nodes.');\n      return;\n    }\n\n    isVisualizingRef.current = true;\n    let visitedNodesInOrder = [];\n    let shortestPath = [];\n\n    if (algorithm === 'dijkstra') {\n      visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'astar') {\n      visitedNodesInOrder = astar(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'bfs') {\n      visitedNodesInOrder = bfs(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    } else if (algorithm === 'dfs') {\n      visitedNodesInOrder = dfs(grid, startNode, endNode);\n      shortestPath = getShortestPath(endNode);\n    }\n\n    animateAlgorithm(visitedNodesInOrder, shortestPath);\n  };\n\n  const dijkstra = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n\n    while (unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) break;\n\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n\n      if (closestNode === endNode) break;\n\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n\n    return visitedNodesInOrder;\n  };\n\n  const astar = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    startNode.heuristic = calculateHeuristic(startNode, endNode);\n    const unvisitedNodes = getAllNodes(grid);\n\n    while (unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) break;\n\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n\n      if (closestNode === endNode) break;\n\n      updateAStarUnvisitedNeighbors(closestNode, endNode, grid, unvisitedNodes);\n    }\n\n    return visitedNodesInOrder;\n  };\n\n  const bfs = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    const queue = [];\n    queue.push(startNode);\n\n    while (queue.length) {\n      const currentNode = queue.shift();\n\n      if (currentNode.isWall) continue;\n      if (currentNode.isVisited) continue;\n\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      if (currentNode === endNode) break;\n\n      const neighbors = getNeighbors(currentNode, grid);\n      for (const neighbor of neighbors) {\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n\n    return visitedNodesInOrder;\n  };\n\n  const dfs = (grid, startNode, endNode) => {\n    const visitedNodesInOrder = [];\n    const stack = [];\n    stack.push(startNode);\n\n    while (stack.length) {\n      const currentNode = stack.pop();\n\n      if (currentNode.isWall) continue;\n      if (currentNode.isVisited) continue;\n\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      if (currentNode === endNode) break;\n\n      const neighbors = getNeighbors(currentNode, grid);\n      for (const neighbor of neighbors) {\n        neighbor.previousNode = currentNode;\n        stack.push(neighbor);\n      }\n    }\n\n    return visitedNodesInOrder;\n  };\n\n  const getAllNodes = (grid) => {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  };\n\n  const sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  };\n\n  const sortNodesByHeuristic = (unvisitedNodes) => {\n    unvisitedNodes.sort(\n      (nodeA, nodeB) =>\n        nodeA.distance + nodeA.heuristic - (nodeB.distance + nodeB.heuristic)\n    );\n  };\n\n  const updateUnvisitedNeighbors = (node, grid) => {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  };\n\n  const updateAStarUnvisitedNeighbors = (node, endNode, grid, unvisitedNodes) => {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      const distanceToNeighbor = node.distance + 1;\n      if (distanceToNeighbor < neighbor.distance) {\n        neighbor.distance = distanceToNeighbor;\n        neighbor.previousNode = node;\n        neighbor.heuristic = calculateHeuristic(neighbor, endNode);\n      }\n    }\n    sortNodesByHeuristic(unvisitedNodes);\n  };\n\n  const calculateHeuristic = (node, endNode) => {\n    const dx = Math.abs(node.col - endNode.col);\n    const dy = Math.abs(node.row - endNode.row);\n    return dx + dy;\n  };\n\n  const getNeighbors = (node, grid) => {\n    const { col, row } = node;\n    const neighbors = [];\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\n  };\n\n  const getShortestPath = (endNode) => {\n    const shortestPath = [];\n    let currentNode = endNode;\n    while (currentNode !== null) {\n      shortestPath.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, shortestPath) => {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n\n    setTimeout(() => {\n      animateShortestPath(shortestPath);\n    }, 10 * visitedNodesInOrder.length);\n  };\n\n  const animateShortestPath = (shortestPath) => {\n    for (let i = 0; i < shortestPath.length; i++) {\n      setTimeout(() => {\n        const node = shortestPath[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n\n    setTimeout(() => {\n      isVisualizingRef.current = false;\n      const timeElapsed = 50 * shortestPath.length;\n      setTimeTaken(timeElapsed);\n    }, 50 * shortestPath.length);\n  };\n\n\n  return (\n    <div className=\"visualizer\">\n      <div className=\"button-container\">\n      <h1>Pathfinder</h1>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => setMouseIsPressed('start')}\n        >\n          Select Start Node\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => setMouseIsPressed('end')}\n        >\n          Select End Node\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => setMouseIsPressed('wall')}\n        >\n          Add Walls\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => visualizeAlgorithm('dijkstra')}\n        >\n          Dijkstra's Algorithm\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => visualizeAlgorithm('astar')}\n        >\n          A* Search\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => visualizeAlgorithm('bfs')}\n        >\n          BFS\n        </button>\n        <button\n          className=\"visualizer-button\"\n          onClick={() => visualizeAlgorithm('dfs')}\n        >\n          DFS\n        </button>\n      </div>\n      <div className=\"time-taken\">\n        Time Taken: {timeTaken} ms\n      </div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex} className=\"row\">\n              {row.map((node, nodeIndex) => {\n                const { col, row, isStart, isEnd, isWall } = node;\n                return (\n                  <Node\n                    key={nodeIndex}\n                    col={col}\n                    row={row}\n                    isStart={isStart}\n                    isEnd={isEnd}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    onMouseDown={() => handleMouseDown(row, col)}\n                    onMouseEnter={() => handleMouseEnter(row, col)}\n                    onMouseUp={handleMouseUp}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default Visualizer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}